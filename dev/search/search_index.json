{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Danger</p> <p>This documentation is a work in progress and may at times be incorrect or behind. For the latest info, check out the source code.</p> <p>Vexo is a component library for PHP to help you develop AI-driven applications quickly. Specifically, it enables you to use large language models as reasoning engines and build workflows around them.</p> <p>Vexo provides two primary components to achieve this; Chains and Agents. Additionally, Vexo provides some ancillary components to help you implement common use cases.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#060","title":"0.6.0","text":"<ul> <li>Moved Prompt and OutputParser to LanguageModelChain namespace</li> <li>Moved TextSplitter and Tokenizer to DocumentLoader namespace</li> <li>Refactored chains for easier usage and clarity</li> <li>Removed superfluous event dispatching logic</li> <li>Switched to twig-based prompt templates</li> <li>LanguageModelChain now always has an output parser</li> <li>Refactored agents for easier usage and clarity</li> <li>Added OpenAI completions model</li> </ul>"},{"location":"changelog/#051","title":"0.5.1","text":"<ul> <li>Fix incorrect prompt template value replacement</li> </ul>"},{"location":"changelog/#050","title":"0.5.0","text":"<ul> <li>Extracted common data structures to contracts for interoperability</li> <li>Reorganised namespaces</li> <li>Added VectorStore component</li> <li>Added Retriever component</li> <li>Added LanguageModelChain factory and initial blueprints</li> <li>Added ConcatenateDocuments Chain</li> <li>Added DocumentsRetrieverChain</li> <li>Added CsvFileLoader</li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<ul> <li>Added Compare component</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<ul> <li>Cleaned up library dependencies</li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<ul> <li>Lots of coding style fixes</li> <li>Renamed Vexo\\Model to Vexo\\LanguageModel</li> <li>Made FinishedGeneratingCompletion event have the whole response instead of just completions</li> <li>Added Vexo\\LanguageModel\\BaseLanguageModel to implement custom models</li> <li>Removed unneeded Vexo\\LanguageModel\\Parameters class</li> <li>Added first version of embeddings</li> <li>Added Tokenizer abstraction</li> <li>Simplified TextSplitters</li> <li>Added TokenTextSplitter that can split text by tokens</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li>FakeLanguageModel now also implements EventDispatcherAware for interoperability</li> <li>RegexOutputParser now has default prompt instructions</li> <li>Chain\\Input and Chain\\Output are now complete collection classes</li> <li>Added ability for WebTextChain to auto discover HTTP client</li> <li>Allow for injection of a custom TextExtractor in WebTextChain</li> <li>Added ability to override the default generated cache key prefix to CachingChain</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li>Initial release.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are very much appreciated! There are several ways you can help with the project.</p>"},{"location":"contributing/#coding-guidelines","title":"Coding Guidelines","text":"<ul> <li>Vexo is meant to be lean and focussed and therefore not all feature requests will be accepted.</li> <li>Compatibility breaks or major changes should first be proposed in a GitHub issue outlining why the change is needed, what the benefits are, and what alternatives have been considered.</li> <li>Vexo has minimum PHP version requirement of PHP 8.1. Pull requests must not require a higher version.</li> <li>All code contributions must be accompanied by unit tests to ensure the change works as expected.</li> <li>All code contributions should pass coding style requirements enforced by PHPStan and PHP-CS-Fixer.</li> </ul>"},{"location":"contributing/#running-the-tests","title":"Running the tests","text":"<ol> <li> <p>Clone the repository: <pre><code>git clone git@github.com:VexoAI/vexo.git &amp;&amp; cd vexo\n</code></pre></p> </li> <li> <p>Install dependencies using Composer: <pre><code>composer install\n</code></pre></p> </li> <li> <p>Run the tests <pre><code>./run-tests.sh\n</code></pre></p> </li> </ol>"},{"location":"contributing/#contribution-documentation","title":"Contribution documentation","text":"<p>Vexo's documentation is maintained in a seperate repository. If you notice any mistakes or would like to expand our documentation with more information, feel free to create an issue there or submit a pull request.</p>"},{"location":"contributing/#where-can-i-go-for-help","title":"Where can I go for help?","text":"<p>If you need help, feel free to create an issue with your question and we'll help you as best we can.</p> <p>Thank you for considering contributing to the project!</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<p>Vexo requires at least PHP 8.1. Some of the components require additional PHP extensions and tooling to function. See the individual component documentation for more info.</p>"},{"location":"installation/#installation_1","title":"Installation","text":"<p>The recommended way to install Vexo is through Composer.</p> <pre><code>composer require vexo/vexo\n</code></pre> <p>When you want to make use of individual components, you have to install them separately. Please check the individual component documentation for the package name and further installation instructions.</p> <p>Notice</p> <p>Currently all of Vexo is contained in a single package. The command above will pull in all the components and their dependencies. In the future this will be split up in multiple component packages so you are able to only pull in what you need.</p>"},{"location":"license/","title":"License","text":"<p>Vexo is released under the MIT license.</p> <pre><code>Copyright (c) 2023 Frank van den Brink\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished\nto do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n</code></pre>"},{"location":"security-policy/","title":"Security policy","text":"<p>We want to make sure that Vexo is a secure library for all. If you have discovered a security vulnerability in Vexo, we appreciate your help in disclosing it to us in a responsible manner.</p> <p>If you have discovered a vulnerability, please use submit a new security advisory for review. We'll work with you to make sure that we understand the scope of the issue, and that we fully address your concern.</p> <p>After a security issue has been corrected, we'll release a new hotfix as soon as possible.</p>"},{"location":"security-policy/#supported-versions","title":"Supported versions","text":"<p>Please see below which issues are still supported for security issues.</p> Version Supported 0.x"},{"location":"chain/building-your-own/","title":"Building your own","text":"<p>To build your own chain, simply implement the <code>Vexo\\Chain\\Chain</code> interface. It has a single method <code>run</code> which accepts an instance of <code>Vexo\\Chain\\Context</code>. The chain can then use the context to get and set values.</p> <pre><code>&lt;?php\ninterface Chain\n{\npublic function run(Context $context): void;\n}\n</code></pre>"},{"location":"chain/building-your-own/#example","title":"Example","text":"<p>In the following example we build a basic chain which takes documents from the context, and splits them into smaller chunks using a <code>CharacterTextSplitter</code>.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Chain;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\nuse Vexo\\Document\\TextSplitter\\TextSplitter;\nfinal class SplitDocumentsChain implements Chain\n{\npublic function __construct(\nprivate readonly TextSplitter $splitter\n) {\n}\npublic function run(Context $context): void\n{\n// Get the documents from the context\n$documents = $context-&gt;get('documents');\n// Use the text splitter to split them\n$splitDocuments = $this-&gt;splitter-&gt;split($documents);\n// Put the split documents back into the context\n$context-&gt;put('split_documents', $splitDocuments);\n}\n}\n// Instantiate our chain\n$chain = new SplitDocumentsChain(new CharacterTextSplitter());\n// Call the chain\n$context = new Context(['documents' =&gt; $documents]); // Documents is an instance of Documents\n$chain-&gt;run($context);\n// Get the split documents from the context\n$splitDocuments = $context-&gt;get('split_documents');\n</code></pre>"},{"location":"chain/building-your-own/#asserting-context-values","title":"Asserting context values","text":"<p>Usually we want to make sure that the context contains the appropriate values before we run a chain.</p> <p>Vexo comes with a <code>Vexo\\Chain\\ContextAssert</code> class which can be used to assert that the context contains the appropriate values. It is based on <code>webmozart/assert</code> and has the same interface. The only difference is that it will raise the appropriate exceptions if the assertions fail.</p> <p>If in the example above we want to make sure that the context contains a documents value and that it is an instance of the <code>Documents</code> class, we can simply assert its type as shown in the highlighted lines below.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Chain;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\ContextAssert;\nuse Vexo\\Document\\TextSplitter\\TextSplitter;\nfinal class SplitDocumentsChain implements Chain\n{\npublic function __construct(\nprivate readonly TextSplitter $splitter\n) {\n}\npublic function run(Context $context): void\n{\n// Get the documents from the context\n$documents = $context-&gt;get('documents');\nContextAssert::isInstanceOf($documents, Documents::class); // Assert our documents\n// Use the text splitter to split them\n$splitDocuments = $this-&gt;splitter-&gt;split($documents);\n// Put the split documents back into the context\n$context-&gt;put('split_documents', $splitDocuments);\n}\n}\n</code></pre>"},{"location":"chain/building-your-own/#customizable-input-and-output-keys","title":"Customizable input and output keys","text":"<p>Usually we want to offer the flexibility to the user to specify which context values should be used as input and output. A simple way to do this is by accepting input and output maps in the constructor where the user can define which values should be used for which keys.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Chain;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\ContextAssert;\nuse Vexo\\Document\\TextSplitter\\TextSplitter;\nfinal class SplitDocumentsChain implements Chain\n{\nprivate const INPUT_DOCUMENTS = 'documents';\nprivate const OUTPUT_SPLIT_DOCUMENTS = 'split_documents';\npublic function __construct(\nprivate readonly TextSplitter $splitter,\nprivate readonly array $inputMap = [],\nprivate readonly array $outputMap = []\n) {\n}\npublic function run(Context $context): void\n{\n// Get the documents from the context\n$documents = $context-&gt;get(\n$this-&gt;inputMap[self::INPUT_DOCUMENTS] ?? self::INPUT_DOCUMENTS\n);\nContextAssert::isInstanceOf($documents, Documents::class); // Assert our documents\n// Use the text splitter to split them\n$splitDocuments = $this-&gt;splitter-&gt;splitDocuments($documents);\n// Put the split documents back into the context\n$context-&gt;put(\n$this-&gt;outputMap[self::OUTPUT_SPLIT_DOCUMENTS] ?? self::OUTPUT_SPLIT_DOCUMENTS,\n$splitDocuments\n);\n}\n}\n</code></pre>"},{"location":"chain/building-your-own/#throwing-exceptions","title":"Throwing exceptions","text":"<p>If you need to throw an exception from your chain, you can extend the <code>Vexo\\Chain\\FailedToRunChain</code> exception class with your own exception and throw that. Any exceptions thrown should extend that class.</p>"},{"location":"chain/getting-started/","title":"Getting started","text":"<p>Chains provide a generic way to compose workflows around large language models.</p> <p>The concept of a chain is rather simple; it performs an action given a certain context, and then manipulates that context. Some chains allow you to combine multiple chains together to create elaborate workflows.</p> <p>The following is an example of a simple workflow where we use a <code>WebTextChain</code> to load text from a webpage, and then pass that to a <code>LanguageModelChain</code> for summarization.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\nuse Vexo\\Chain\\SequentialChain\\SequentialChain;\nuse Vexo\\Chain\\WebTextChain\\WebTextChain;\nuse Vexo\\Model\\Language\\OpenAIChatModel;\n// Load our language model using OpenAI\n$languageModel = new OpenAIChatModel(\n\\OpenAI::client(\"sk-AbCdEfG987...\")-&gt;chat()\n);\n// Initialize our sequential chain and the two needed chains in order\n$sequentialChain = new SequentialChain(\nchains: [\n// Create our WebTextChain which will take a URL from the context, downloads the\n// web page, and saves the text contents in the context\nnew WebTextChain(),\n// Create our LanguageModelChain using the language model above and a basic prompt\n// renderer, which will ask the language model to summarize the given text.\nnew LanguageModelChain(\nlanguageModel: $languageModel,\npromptRenderer: new StrReplaceRenderer(\"Summarize the text below:\\n\\n{{text}}\")\n)\n]\n);\n// Create the context the chains will operate on, with our initial URL\n$context = new Context(['url' =&gt; 'https://www.example.com']);\n// Run the chains on the context\n$sequentialChain-&gt;run($context);\n// Show the summarized webpage\necho $context-&gt;get('generation'); // Outputs something like: The Example Domain can be...\n</code></pre>"},{"location":"chain/getting-started/#remapping-context-values","title":"Remapping context values","text":"<p>In the example above we are relying on the default context values matching up between the different chains. For instance, the <code>WebTextChain</code> needs the \"url\" value to be available in the context, and then puts a new \"text\" value in the context which the <code>LanguageModelChain</code> then uses as part of the prompt.</p> <p>Sometimes these values don't line up or you simply want to rename these. You can control what these values are called by providing the <code>inputMap</code> and <code>outputMap</code> variables to a chain.</p> <pre><code>&lt;?php\n$sequentialChain = new SequentialChain(\nchains: [\nnew WebTextChain(\n// Context needs a \"link\" value with the URL\ninputMap: ['url' =&gt; 'link'],\n// Contents of the webpage are put in \"webpage\" instead of \"text\"\noutputMap: ['text' =&gt; 'webpage']\n),\nnew LanguageModelChain(\nlanguageModel: $languageModel,\npromptRenderer: new StrReplaceRenderer(\"Summarize the text below:\\n\\n{{text}}\"),\n// Make sure the contents of \"webpage\" can be used as \"text\" in the prompt above\ninputMap: ['text' =&gt; 'webpage'],\n// The generated value of the LLM is now available as \"summary\" in the context\noutputMap: ['generation' =&gt; 'summary']\n)\n]\n);\necho $context-&gt;get('summary'); // This will now work\n</code></pre> <p>Any chain that operates on the context directly will support these parameters.</p>"},{"location":"chain/getting-started/#monitoring-events","title":"Monitoring events","text":"<p>The <code>SequentialChain</code> (and some others) support event dispatching. You can pass a PSR-14 compatible event dispatcher in the <code>eventDispatcher</code> parameter which will then be used to dispatch events.</p> <pre><code>&lt;?php\nuse Vexo\\Contract\\Event\\Event;\n$sequentialChain = new SequentialChain(\neventDispatcher: $eventDispatcher, // Your PSR-14 compatible dispatcher\nchains: [\n// ...\n]\n);\n$eventDispatcher-&gt;subscribeTo(\nEvent::class,\nfunction (Event $event): void {\n// Handle the event\n}\n);\n</code></pre> <p>The individual chain documentation will indicate which events are dispatched and when, if any.</p>"},{"location":"chain/getting-started/#handling-exceptions","title":"Handling exceptions","text":"<p>If a chain fails for any reason, an instance of <code>Vexo\\Chain\\FailedToRunChain</code> is thrown. All chain exceptions extend this class.</p> <p>When the chain cannot retrieve required input from the context, an instance of <code>Vexo\\Chain\\FailedToGetContextValue</code> is thrown.</p> <p>Additionally specific chains may throw other exceptions in different fail cases, but they will all extend from <code>FailedToRunChain</code>.</p>"},{"location":"chain/document-chains/CombineDocumentsChain/","title":"CombineDocumentsChain","text":"<p>The <code>CombineDocumentsChain</code> takes multiple documents and combines their contents into a single piece of text.</p>"},{"location":"chain/document-chains/CombineDocumentsChain/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\CombineDocumentsChain\\CombineDocumentsChain;\nuse Vexo\\Document\\Document;\nuse Vexo\\Document\\Documents;\n// Set up our chain\n$combineDocumentsChain = new CombineDocumentsChain();\n// Create a context with some documents\n$context = new Context([\n'documents' =&gt; new Documents([\nnew Document('Roses are red'),\nnew Document('Violets are blue')\n])\n]);\n// Call the chain\n$combineDocumentsChain-&gt;run($context);\n// The combined contents are now available in the context\n//\n// Outputs:\n//\n// Roses are red\n//\n// Violets are blue\n//\necho $context-&gt;get('combined_contents');\n</code></pre>"},{"location":"chain/document-chains/DocumentsRetrieverChain/","title":"DocumentsRetrieverChain","text":"<p>The <code>DocumentsRetrieverChain</code> takes a query and then uses a document retriever to load documents into the current context.</p> <p>This will allow you to use any retriever to load documents, and then use the documents in the context in other chains.</p>"},{"location":"chain/document-chains/DocumentsRetrieverChain/#example","title":"Example","text":"<p>In the example below we use a Vector Store retriever to load documents from a vector store into the current context.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\DocumentsRetrieverChain\\DocumentsRetrieverChain;\nuse Vexo\\Document\\Retriever\\VectorStoreRetriever;\n$vectorStore = ...; // An implementation of Vexo\\VectorStore\\VectorStore\n// Create our documents retriever chain\n$retrieverChain = new DocumentsRetrieverChain(\nretriever: new VectorStoreRetriever( // Any concrete Vexo\\Document\\Retriever\\Retriever\nvectorStore: $vectorStore\n),\nmaxResults: 3\n);\n// Call the chain\n$context = new Context(['query' =&gt; 'Regulation of gene expression']);\n$retrieverChain-&gt;run($context);\n// The documents are now available in the context\n$documents = $context-&gt;get('documents'); // Instance of Vexo\\Document\\Documents\n</code></pre>"},{"location":"chain/execution-chains/BranchingChain/","title":"BranchingChain","text":"<p>The <code>BranchingChain</code> allows you to create multiple execution paths within your workflows by evaluating the context before executing a chain.</p> <p>You can nest multiple chains within the <code>BranchingChain</code> paired with a condition. Conditions are then executed in order, and if they evaluate to <code>true</code>, the chain is executed. If multiple conditions evaluate to <code>true</code>, multiple chains will be executed.</p> <p>All the values contained in the context are available for evaluation.</p>"},{"location":"chain/execution-chains/BranchingChain/#requirements","title":"Requirements","text":"<p>The condition is evaluated using the Symfony ExpressionLanguage component and requires this to be available in your project.</p> <pre><code>composer require symfony/expression-language\n</code></pre>"},{"location":"chain/execution-chains/BranchingChain/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Chain\\BranchingChain\\BranchingChain;\nuse Vexo\\Chain\\Chain;\nuse Vexo\\Chain\\Context;\n$context = new Context([\n'amount' =&gt; 42,\n'thing' =&gt; ['foo' =&gt; 'bar'],\n'action' =&gt; 'some-chain',\n'definitely' =&gt; true\n]);\n$branchingChain = new BranchingChain(\nchains: [\n\"amount in 40..100\"                   =&gt; new Chain(...), // true\n\"action in ['some-chain', 'another']\" =&gt; new Chain(...), // true\n\"thing['foo'] == 'bar'\"               =&gt; new Chain(...), // true\n\"definitely\"                          =&gt; new Chain(...), // true\n\"doesNotExist\"                        =&gt; new Chain(...)  // Throws an exception\n]\n);\n$branchingChain-&gt;run($context);\n</code></pre>"},{"location":"chain/execution-chains/BranchingChain/#condition-syntax","title":"Condition syntax","text":"<p>The ExpressionLanguage component gives you a lot of different ways to evaluate the given context. For more information on the syntax and possible evaluations, have a look at The Expression Syntax.</p>"},{"location":"chain/execution-chains/BranchingChain/#syntax-errors","title":"Syntax errors","text":"<p>On syntax error or references to non-existent values, a <code>FailedToEvaluateCondition</code> exception is thrown explaining the error.</p>"},{"location":"chain/execution-chains/BranchingChain/#events","title":"Events","text":"<p>The <code>BranchingChain</code> will emit the following events.</p>"},{"location":"chain/execution-chains/BranchingChain/#chainbranchconditionevaluated","title":"<code>ChainBranchConditionEvaluated</code>","text":"<p>Emitted when the condition has been evaluated. The following methods are available on the event.</p> Method Description <code>chainIdentifier(): string</code> The unique object ID of the chain who's condition is being evaluated. <code>chainClass(): string</code> The fully-qualified class name of the chain. <code>context(): Context</code> The context object used for the evaluation. <code>condition(): string</code> The condition being evaluated. <code>evaluationResult(): bool</code> What the condition evaluated to."},{"location":"chain/execution-chains/BranchingChain/#chainstarted","title":"<code>ChainStarted</code>","text":"<p>Emitted when the <code>BranchingChain</code> is starting execution of the chain, after the condition evaluates to <code>true</code>.</p> Method Description <code>chainIdentifier(): string</code> The unique object ID of the chain which is being executed. <code>chainClass(): string</code> The fully-qualified class name of the chain. <code>context(): Context</code> The context object passed to the chain."},{"location":"chain/execution-chains/BranchingChain/#chainfinished","title":"<code>ChainFinished</code>","text":"<p>Emitted when the <code>BranchingChain</code> has finished execution of a chain.</p> Method Description <code>chainIdentifier(): string</code> The unique object ID of the chain which is being executed. <code>chainClass(): string</code> The fully-qualified class name of the chain. <code>context(): Context</code> The context object passed to the chain."},{"location":"chain/execution-chains/CachingChain/","title":"CachingChain","text":"<p>The <code>CachingChain</code> wraps another chain to provide it with caching capabilities. It relies on being provided a PSR-16 compatible cache implementation.</p> <p>It caches specified output context values, and does this by fingerprinting specified input context values. If the input context values are different from previous cache entries, the chain will be executed and the output context values will be cached.</p>"},{"location":"chain/execution-chains/CachingChain/#requirements","title":"Requirements","text":"<p>The <code>CachingChain</code> requires a PSR-16 compatible cache implementation to be provided.</p> <p>We recommend using the Symfony Cache component but you can any any PSR-16 compatible implementation. You can find a list of implementations here.</p> <pre><code>composer require symfony/cache\n</code></pre>"},{"location":"chain/execution-chains/CachingChain/#example","title":"Example","text":"<p>In the example below we wrap a WebTextChain to cache webpage text extractions using <code>symfony/cache</code>.</p> <pre><code>&lt;?php\nuse Symfony\\Component\\Cache\\Adapter\\ArrayAdapter;\nuse Symfony\\Component\\Cache\\Psr16Cache;\nuse Vexo\\Chain\\CachingChain;\nuse Vexo\\Chain\\WebTextChain;\n// Create our caching chain\n$cachingChain = new CachingChain(\nchain: new WebTextChain(),                 // The chain to wrap\ncache: new Psr16Cache(new ArrayAdapter()), // The cache implementation\ninputValuesToMatch: ['url']                // The input values to fingerprint\noutputValuesToCache: ['text']              // The output values to cache\n);\n// The first run will execute the chain and cache the output values\n$context = new Context(['url' =&gt; 'https://example.com/']);\n$cachingChain-&gt;run($context);\necho $context-&gt;get('text') . PHP_EOL; // Outputs the text of the webpage\n// The second run will not execute the chain, but return the cached output values\n$context = new Context(['url' =&gt; 'https://example.com/']);\n$cachingChain-&gt;run($context);\necho $context-&gt;get('text') . PHP_EOL; // Same output, this time returned from cache\n</code></pre>"},{"location":"chain/execution-chains/CachingChain/#cache-lifetime","title":"Cache lifetime","text":"<p>By default no cache lifetime is specified for the cache entries, which means that whatever default lifetime set on the PSR-16 cache implementation will be used. If you want to specify a lifetime for the cache entries, you can do so by passing the number of seconds the entries should last as the <code>lifetime</code> argument to the <code>CachingChain</code> constructor.</p> <pre><code>&lt;?php\n// Create our caching chain\n$cachingChain = new CachingChain(\nchain: new WebTextChain(),                 // The chain to wrap\ncache: new Psr16Cache(new ArrayAdapter()), // The cache implementation\ninputValuesToMatch: ['url']                // The input values to fingerprint\noutputValuesToCache: ['text']              // The output values to cache,\nlifetime: 3600                             // The cache lifetime in seconds\n);\n</code></pre>"},{"location":"chain/execution-chains/CachingChain/#cache-key-prefix","title":"Cache key prefix","text":"<p>By default the cache key prefix is <code>vexo.chain.cache</code>. If you want to specify a different cache key prefix, you can do so by passing the prefix as the <code>cacheKeyPrefix</code> argument to the <code>CachingChain</code> constructor.</p> <pre><code>&lt;?php\n// Create our caching chain\n$cachingChain = new CachingChain(\nchain: new WebTextChain(),                 // The chain to wrap\ncache: new Psr16Cache(new ArrayAdapter()), // The cache implementation\ninputValuesToMatch: ['url']                // The input values to fingerprint\noutputValuesToCache: ['text']              // The output values to cache,\ncacheKeyPrefix: 'acme.chain.cache'         // The cache key prefix\n);\n</code></pre>"},{"location":"chain/execution-chains/SequentialChain/","title":"SequentialChain","text":"<p>The <code>SequentialChain</code> allows you to connect multiple chains in sequence. This is useful when you, for instance, want to create more complex workflows involving one or more language models.</p> <p>Values added to the context in one chain, are available for usage in the next chains.</p>"},{"location":"chain/execution-chains/SequentialChain/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Chain\\Chain;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\SequentialChain\\SequentialChain;\n$context = new Context([\n'amount' =&gt; 42\n]);\n$sequentialChain = new SequentialChain(\nchains: [\nnew Chain(...), // Ran first\nnew Chain(...), // Ran second\n// etc\n]\n);\n$sequentialChain-&gt;run($context);\n</code></pre>"},{"location":"chain/execution-chains/SequentialChain/#events","title":"Events","text":"<p>The <code>SequentialChain</code> will emit the following events.</p>"},{"location":"chain/execution-chains/SequentialChain/#chainstarted","title":"<code>ChainStarted</code>","text":"<p>Emitted when the <code>SequentialChain</code> is starting execution of a chain.</p> Method Description <code>chainIdentifier(): string</code> The unique object ID of the chain which is being executed. <code>chainClass(): string</code> The fully-qualified class name of the chain. <code>context(): Context</code> The context object passed to the chain."},{"location":"chain/execution-chains/SequentialChain/#chainfinished","title":"<code>ChainFinished</code>","text":"<p>Emitted when the <code>SequentialChain</code> has finished execution of a chain.</p> Method Description <code>chainIdentifier(): string</code> The unique object ID of the chain which is being executed. <code>chainClass(): string</code> The fully-qualified class name of the chain. <code>context(): Context</code> The context object passed to the chain."},{"location":"chain/external-systems/WebTextChain/","title":"WebTextChain","text":"<p>The <code>WebTextChain</code> takes a URL and loads a plain text version of the page into the current context. By default the chain will load the first 8k of plain text from the page, but this can be configured by passing the <code>maxTextLength</code> argument to the constructor.</p> <p>The chain will strip all HTML and tags which are not part of the page content, such as <code>&lt;script&gt;</code> and <code>&lt;style&gt;</code> tags.</p>"},{"location":"chain/external-systems/WebTextChain/#requirements","title":"Requirements","text":"<p>This chain relies on <code>php-http/discovery</code> to find a PSR-18 compatible HTTP client. You can find a list of possible implementations here.</p>"},{"location":"chain/external-systems/WebTextChain/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\WebTextChain\\WebTextChain;\n// Set up our chain\n$webTextChain = new WebTextChain(\nmaxTextLength: 4000 // The maximum length of the text to extract; defaults to 8k\n);\n// Call the chain\n$context = new Context('url' =&gt; 'https://www.example.com');\n$webTextChain-&gt;run($context);\n// The plain text is now available in the context\necho $context-&gt;get('text'); // Outputs the plain text of the page\n</code></pre>"},{"location":"chain/external-systems/WebTextChain/#overriding-the-default-http-client","title":"Overriding the default HTTP client","text":"<p>If you don't want to rely on <code>php-http/discovery</code> to select an HTTP client, you can pass a PSR-18 compatible HTTP client and/or a PSR-17 compatible request factory to the <code>WebTextChain</code> constructor.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\WebTextChain\\WebTextChain;\n// Set up our chain\n$webTextChain = new WebTextChain(\nhttpClient: $httpClient, // Any PSR-18 compatible HTTP client\nrequestFactory: $requestFactory // Any PSR-17 compatible request factory\n);\n</code></pre>"},{"location":"chain/language-model-chain/blueprints/","title":"Blueprints","text":"<p>Blueprints are a way to define a set of parameters that commonly go together when creating new language model chains. Very often the prompt renderer, language model, and output parser are coupled, as the prompt commonly contains instructions on how the language model should format its output. Blueprints allow you to define these as a single unit.</p>"},{"location":"chain/language-model-chain/blueprints/#common-blueprints","title":"Common blueprints","text":"<p>The following blueprints are provided out of the box.</p> Blueprint Description AnswerQuestionAboutContext Instructs a model to answer a question about a given context. ReasonAndAct Employs the Reason and Act paradigm for more complex reasoning."},{"location":"chain/language-model-chain/blueprints/#using-blueprints","title":"Using blueprints","text":"<p>You can use the <code>LanguageModelChainFactory</code> to create a chain from a blueprint.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\Blueprint\\AnswerQuestionAboutContext;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChainFactory;\n// Create the LanguageModelChain\n$factory = new LanguageModelChainFactory($languageModel); // Use our preinitialized model\n$chain = $factory-&gt;createFromBlueprint(\nblueprint: new AnswerQuestionAboutContext(),\n// The following is optional; if you want to remap the input/output values\ninputMap: ['question' =&gt; 'query', 'context' =&gt; 'article'],\noutputMap: ['answer' =&gt; 'result']\n);\n// Run the chain!\n$context = new Context([\n'query' =&gt; 'What is the article about?',\n'article' =&gt; 'Some long article...'\n]);\n$chain-&gt;run($context);\n// Outputs something like: This article is about...\necho $context-&gt;get('result');\n</code></pre>"},{"location":"chain/language-model-chain/blueprints/#creating-your-own","title":"Creating your own","text":"<p>You can create your own blueprint by implementing the <code>Vexo\\Chain\\LanguageModelChain\\Blueprint</code> interface. It should define a prompt renderer, an output parser, and a list of stop tokens.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\OutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\Renderer;\ninterface Blueprint\n{\npublic function promptRenderer(): Renderer;\npublic function outputParser(): OutputParser;\n/**\n     * @return array&lt;string&gt;\n     */\npublic function stops(): array;\n}\n</code></pre>"},{"location":"chain/language-model-chain/blueprints/#example","title":"Example","text":"<p>What follows is a basic blueprint which will ask the model to classify a given piece of text and output its classification as JSON.</p> <pre><code>&lt;?php\nnamespace Acme;\nuse Vexo\\Chain\\LanguageModelChain\\Blueprint;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\JsonOutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\nfinal class ClassifyText implements Blueprint\n{\npublic function promptRenderer(): Renderer\n{\n$schemaAsJson = json_encode($this-&gt;schema());\nreturn new StrReplaceRenderer(\n&lt;&lt;&lt;PROMPT_TEMPLATE\n            Classify the text below by sentiment. It is either positive or negative.\n            Output the classification as valid JSON. Your output should adhere to the\n            following schema:\n            {$schemaAsJson}\n            Do not output anything else. The text is:\n            {{text}}\n            Classification JSON:\nPROMPT_TEMPLATE\n);\n}\npublic function outputParser(): OutputParser\n{\nreturn JsonOutputParser::createWithSchema($this-&gt;schema());\n}\npublic function stops(): array\n{\nreturn [];\n}\nprivate function schema(): object\n{\nreturn (object) [\n'type' =&gt; 'object',\n'properties' =&gt; (object) [\n'sentiment' =&gt; (object) ['type' =&gt; 'string']\n],\n'required' =&gt; ['sentiment']\n];\n}\n}\n</code></pre> <p>You can then use it as you would any other blueprint.</p> <pre><code>&lt;?php\nuse Acme\\ClassifyText;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChainFactory;\n// Create the LanguageModelChain\n$factory = new LanguageModelChainFactory($languageModel); // Use our preinitialized model\n$chain = $factory-&gt;createFromBlueprint(new ClassifyText());\n// Run the chain!\n$context = new Context([\n'text' =&gt; 'My life is amazing!'\n]);\n$chain-&gt;run($context);\necho $context-&gt;get('sentiment'); // Outputs: positive\n</code></pre>"},{"location":"chain/language-model-chain/introduction/","title":"Introduction","text":"<p>The <code>LanguageModelChain</code> is at the heart of Vexo. In its most basic form it has a single dependency, an instance of <code>Vexo\\Model\\Language\\LanguageModel</code>.</p>"},{"location":"chain/language-model-chain/introduction/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Model\\Language\\OpenAIChatModel;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\n// Initialize our OpenAI client\n$chat = \\OpenAI::client(getenv('OPENAI_API_KEY'));\n// Initialize our language model\n$languageModel = new OpenAIChatModel($openAI-&gt;chat());\n// Create the LanguageModelChain\n$chain = new LanguageModelChain($languageModel);\n// Run the chain!\n$context = new Context(['prompt' =&gt; 'What is the capital of France?']);\n$chain-&gt;run($context);\n// Outputs something like: The capital of France is Paris\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/introduction/#prompt-rendering","title":"Prompt rendering","text":"<p>The example above is not terribly useful, as it relies on a static prompt being available in the context. Vexo comes a few different prompt renderers that will allow you to render prompts dynamically based on context values.</p> <p>In the example below we use the basic <code>StrReplaceRenderer</code> to render our prompt.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // As before\npromptRenderer: new StrReplaceRenderer('What is the capital of {{country}}?')\n);\n// Run the chain!\n$context = new Context(['country' =&gt; 'France']);\n$chain-&gt;run($context);\n// Outputs something like: The capital of France is Paris\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/introduction/#output-parsing","title":"Output parsing","text":"<p>Sometimes the language model produces output which we need to interpret and structure, as opposed to simply using the whole generation as plain text. In that case you can supply an <code>OutputParser</code> to parse the output.</p> <p>In the example below we add a <code>RegexOutputParser</code> to interpret the output.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\RegexOutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // As before\npromptRenderer: new StrReplaceRenderer('What is the capital of {{country}}?'),\noutputParser: new RegexOutputParser('/^The capital of .* is (?P&lt;capital&gt;.*)!$/i')\n);\n// Run the chain!\n$context = new Context(['country' =&gt; 'France']);\n$chain-&gt;run($context);\n// Outputs something like: Paris\necho $context-&gt;get('capital');\n</code></pre>"},{"location":"chain/language-model-chain/introduction/#stop-tokens","title":"Stop tokens","text":"<p>Sometimes language models will produce more output than we need, adding additional explanation beyond its provided instructions. In that case we can provide stop tokens. Stop tokens are words which will trigger the model to stop generating and immediately return its response.</p> <p>These will be directly provided to the underlying model when making the call to generate the response.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // As before\nstops: ['Observation:']\n);\n</code></pre>"},{"location":"chain/language-model-chain/introduction/#remapping-context-values","title":"Remapping context values","text":"<p>In the example above we are relying on the default context values. Sometimes these values don't line up or you simply want to rename these. You can control what these values are called by providing the <code>inputMap</code> and <code>outputMap</code> variables.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // As before\ninputMap: ['prompt' =&gt; 'question'],\noutputMap: ['generation' =&gt; 'answer']\n);\n// Run the chain!\n$context = new Context(['question' =&gt; 'What is the capital of France?']);\n$chain-&gt;run($context);\n// Outputs something like: The capital of France is Paris\necho $context-&gt;get('answer');\n</code></pre> <p>You can do the same for any context values which are needed by the prompt renderer or are produced by the output parser.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\RegexOutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // As before\npromptRenderer: new StrReplaceRenderer('What is the capital of {{country}}?'),\noutputParser: new RegexOutputParser('/^The capital of .* is (?P&lt;capital&gt;.*)!$/i'),\ninputMap: ['country' =&gt; 'nation'],\noutputMap: ['capital' =&gt; 'city']\n);\n// Run the chain!\n$context = new Context(['nation' =&gt; 'France']);\n$chain-&gt;run($context);\n// Outputs something like: Paris\necho $context-&gt;get('city');\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/JsonOutputParser/","title":"JsonOutputParser","text":"<p>The <code>JsonOutputParser</code> allows you to parse output according to a specified JSON Schema. The first level properties of the resulting object will be made available as context values.</p>"},{"location":"chain/language-model-chain/output-parsers/JsonOutputParser/#requirements","title":"Requirements","text":"<p>The <code>JsonOutputParser</code> makes use of the <code>justinrainbow/json-schema</code> library to validate the JSON structure against a JSON schema. It must be available in your project.</p> <pre><code>composer require justinrainbow/json-schema\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/JsonOutputParser/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\JsonOutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\n// Our JSON schema\n$schema = (object) [\n'type' =&gt; 'object',\n'properties' =&gt; (object) [\n'name' =&gt; (object) [\n'type' =&gt; 'string'\n]\n]\n];\n// Our prompt template\n$promptTemplate = &lt;&lt;&lt;PROMPT_TEMPLATE\nProvide a random name and age as valid JSON. Your output must adhere to the following\nschema:\n{{schema}}\nOnly output the code, prefixed with \"```json\" and postfixed with \"```\". Nothing else.\nPROMPT_TEMPLATE;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\npromptRenderer: new StrReplaceRenderer($promptTemplate),\noutputParser: JsonOutputParser::createWithSchema($schema)\n);\n// Run the chain!\n$context = new Context(['schema' =&gt; json_encode($schema));\n$chain-&gt;run($context);\n// Given that the model outputs something as follows:\n//\n// ```json\n// {\"name\": \"John Doe\", \"age\": 42}\n// ```\n//\n// The following value will be set in the context:\necho $context-&gt;get('name') . PHP_EOL;\necho $context-&gt;get('age') . PHP_EOL;\n// Still outputs the whole LLM response, unparsed:\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/JsonOutputParser/#parse-errors","title":"Parse errors","text":"<p>If the parser cannot extract the JSON from the output or if the returned JSON does not adhere to the provided schema, a <code>FailedToParseOutput</code> exception is thrown.</p>"},{"location":"chain/language-model-chain/output-parsers/RegexOutputParser/","title":"RegexOutputParser","text":"<p>The <code>RegexOutputParser</code> allows you to use regular expressions to parse language model output. It will automatically make any named capture groups available as values in the context after parsing.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\RegexOutputParser;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\noutputParser: new RegexOutputParser('/Action: (?P&lt;action&gt;.*?)\\nAction input: (?P&lt;input&gt;.*)/')\n);\n// Run the chain!\n$context = new Context(['prompt' =&gt; 'Please decide on an action and an input']);\n$chain-&gt;run($context);\n// Given that the model outputs something as follows:\n//\n// Action: my action\n// Action input: input to the action\n//\n// The following values will be set in the context:\necho $context-&gt;get('action') . PHP_EOL;\necho $context-&gt;get('input') . PHP_EOL;\n// Still outputs the whole LLM response, unparsed:\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/RegexOutputParser/#parse-errors","title":"Parse errors","text":"<p>If the provided regular expression is invalid, or if the parser failed to find any matches, an instance of the <code>FailedToParseOutput</code> exception will be thrown.</p>"},{"location":"chain/language-model-chain/output-parsers/create-your-own/","title":"Create your own","text":"<p>You can create your own output parser by implementing the <code>Vexo\\Chain\\LanguageModelChain\\OutputParser\\OutputParser</code> interface. It has a single <code>parse</code> method which takes the output to parse as a string, and returns an array of values which should be inserted into the context.</p> <pre><code>&lt;?php\ninterface OutputParser\n{\n/**\n     * @return array&lt;string, string&gt;\n     */\npublic function parse(string $text): array;\n}\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/create-your-own/#example","title":"Example","text":"<p>In the example below we create a simple <code>parse_str</code> based output parser.</p> <pre><code>&lt;?php\nnamespace Acme;\nuse Vexo\\Chain\\LanguageModelChain\\OutputParser\\OutputParser;\nfinal class ParseStrOutputParser implements OutputParser\n{\npublic function parse(string $text): array\n{\n$values = [];\nparse_str($text, $values);\nreturn $values;\n}\n}\n</code></pre> <p>Which you can then use as follows:</p> <pre><code>&lt;?php\nuse Acme\\ParseStrOutputParser;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\noutputParser: new ParseStrOutputParser()\n);\n// Run the chain!\n$context = new Context([\n'prompt' =&gt; 'Give me a name and an age as a URL query string. Only output the part\n                 after \"?\". Do not provide further explanation.'\n]);\n$chain-&gt;run($context);\n// Given that the model outputs something as follows:\n//\n// name=JohnDoe&amp;age=42\n//\n// The following values will be set in the context:\necho $context-&gt;get('name') . PHP_EOL;\necho $context-&gt;get('age') . PHP_EOL;\n// Still outputs the whole LLM response, unparsed:\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/output-parsers/create-your-own/#dealing-with-parse-errors","title":"Dealing with parse errors","text":"<p>Language Models are non-deterministic so you cannot rely on their output being consistent 100% of the time. This means you should program your parser defensively, and be prepared for incorrect output.</p> <p>In general it is best to be as forgiving when you can when parsing the output, however if the language model has made obvious mistakes, it is best to throw an exception with a detailed explanation and have this fed back to the model so it can self-correct.</p> <p>Throw an instance of <code>FailedToParseOutput</code> if that is the case.</p>"},{"location":"chain/language-model-chain/prompt-renderers/StrReplaceRenderer/","title":"StrReplaceRenderer","text":"<p>The <code>StrReplaceRenderer</code> is a basic prompt renderer around PHP's <code>str_replace</code> function. In essence it does little more than replace any occurrence of <code>{{name}}</code> with the context value of the referenced name.</p> <p>This is the best option if your prompt templates are fairly basic and only require basic string interpolation.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\StrReplaceRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\npromptRenderer: new StrReplaceRenderer('What is the capital of {{country}}?')\n);\n// Run the chain!\n$context = new Context(['country' =&gt; 'France']);\n$chain-&gt;run($context);\n// Outputs something like: The capital of France is Paris\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/StrReplaceRenderer/#missing-values","title":"Missing values","text":"<p>If the template references a value which isn't available in the context, a <code>FailedToGetContextValue</code> exception will be thrown.</p>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/","title":"TwigRenderer","text":"<p>The <code>TwigRenderer</code> makes use of Twig templates to render prompts. This allows for a great deal of flexibility in generating more elaborate prompts.</p>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/#requirements","title":"Requirements","text":"<p>The renderer requires you to have Twig installed in your project.</p> <pre><code>composer require twig/twig\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/#example","title":"Example","text":"<p>The renderer has a factory method for convenience which will allow you to specify the location of your prompt template files and the name of the template you would like to use.</p> <p>Assuming you have the following template at <code>/your/project/templates/prompt.twig</code>:</p> <pre><code>Use the following pieces of context to answer the question at the end. If you don't know\nthe answer, just say that you don't know. Don't try to make up an answer.\n{{ context }}\nQuestion: {{ question }}\nHelpful Answer:\n</code></pre> <p>You can render it as follows.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\TwigRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\npromptRenderer: TwigRenderer::createWithFilesystemLoader(\n'prompt.twig'\n'/your/project/templates'\n)\n);\n// Run the chain!\n$context = new Context([\n'context' =&gt; 'Some long article about Edsger Dijkstra...'\n'question' =&gt; 'When was Edsger Dijkstra born?'\n]);\n$chain-&gt;run($context);\n// Outputs something like: Edsget Dijkstra was born on May 11th, 1930\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/#overriding-the-template-loader","title":"Overriding the template loader","text":"<p>If you would like to use a different way to load your templates, or want to provide Twig with more advanced configuration options, you can use the <code>createWithLoader</code> factory method instead and inject your own loader.</p> <pre><code>&lt;?php\nuse Twig\\Loader\\ArrayLoader;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\TwigRenderer;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\npromptRenderer: TwigRenderer::createWithLoader(\n'prompt.twig'\nnew ArrayLoader(['prompt.twig' =&gt; 'What is the capital of {{ country }}?']),\n['debug' =&gt; true] // Optional extra Twig configuration options\n)\n);\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/#template-syntax","title":"Template syntax","text":"<p>Twig's templating language is elaborate and supports many useful features like control structures, filters, expressions, etc. Please have a look at Twig for Template Designers for more information on the possibilities.</p>"},{"location":"chain/language-model-chain/prompt-renderers/TwigRenderer/#missing-values","title":"Missing values","text":"<p>If the template references a value which isn't available in the context, a <code>FailedToGetContextValue</code> exception will be thrown.</p>"},{"location":"chain/language-model-chain/prompt-renderers/create-your-own/","title":"Create your own","text":"<p>You can create your own prompt renderer by implementing the <code>Vexo\\Chain\\LanguageModelChain\\Prompt\\Renderer</code> interface. It has a single <code>render</code> method which takes a context object, and returns the final prompt as a string.</p> <pre><code>&lt;?php\nuse Vexo\\Chain\\Context;\ninterface Renderer\n{\npublic function render(Context $context): string;\n}\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/create-your-own/#example","title":"Example","text":"<p>In the example below we create a simple <code>strtr</code> based prompt renderer.</p> <pre><code>&lt;?php\nnamespace Acme;\nuse Vexo\\Chain\\Context;\nuse Vexo\\Chain\\LanguageModelChain\\Prompt\\Renderer;\nfinal class StrtrRenderer implements Renderer\n{\npublic function __construct(private readonly string $template)\n{\n}\npublic function render(Context $context): string\n{\n$replacements = [];\nforeach ($context as $name =&gt; $value) {\n$replacements[\"{{{$name}}}\"] = $value;\n}\nreturn strtr($this-&gt;template, $replacements);\n}\n}\n</code></pre> <p>You can then use it as follows:</p> <pre><code>&lt;?php\nuse Acme\\StrtrRenderer;\nuse Vexo\\Chain\\LanguageModelChain\\LanguageModelChain;\n// Create the LanguageModelChain\n$chain = new LanguageModelChain(\nlanguageModel: $languageModel, // Our already initialized language model\npromptRenderer: new StrtrRenderer('What is the capital of {{country}}?')\n);\n// Run the chain!\n$context = new Context(['country' =&gt; 'France']);\n$chain-&gt;run($context);\n// Outputs something like: The capital of France is Paris\necho $context-&gt;get('generation');\n</code></pre>"},{"location":"chain/language-model-chain/prompt-renderers/create-your-own/#dealing-with-missing-values","title":"Dealing with missing values","text":"<p>Note that in the example above we do not check for any missing context values. Any referenced values in the template which are not available in the context will simply be skipped over.</p> <p>If you use the <code>Context::get</code> method to extract values, the appropriate exeception will be automatically thrown if the requested value is not available.</p> <p>If you use some other method, like in the example above, it is advisable to throw a <code>FailedToGetContextValue</code> exception yourself if the value is not available.</p>"},{"location":"chain/language-model-chain/prompt-renderers/create-your-own/#dealing-with-rendering-issues","title":"Dealing with rendering issues","text":"<p>If for some reason the prompt cannot be rendered, you should throw a <code>FailedToRenderPrompt</code> exception.</p>"},{"location":"document/introduction/","title":"Introduction","text":"<p>The Document component provides various ways to load, split, and transform text documents for usage with chains, vector stores, and large language models.</p> <p>The basis of the component is the <code>Vexo\\Document\\Document</code> class, which represents a single document. It has two methods, <code>contents</code> and <code>metadata</code>, which return the document's contents and metadata respectively.</p> <p>Documents can contain any sort of contents and any relevant metadata. It is up to you to decide what metadata is relevant to their use case.</p> <p>There is also the <code>Vexo\\Document\\Documents</code> class which represents an iterable collection of documents.</p>"},{"location":"document/introduction/#creating-documents","title":"Creating documents","text":"<p>Generally documents are created by using loaders, but you can also instantiate them directly.</p> <pre><code>&lt;?php\nuse Vexo\\Contract\\Metadata;\nuse Vexo\\Document\\Document;\nuse Vexo\\Document\\Documents;\n// Create our document\n$document = new Document(\ncontents: 'This is the document contents.',\nmetadata: new Metadata([\n'id' =&gt; 1234,\n'title' =&gt; 'Document title',\n'something_else' =&gt; 'Some other metadata'\n])\n);\n// Put it in a collection\n$documents = new Documents([$document]);\n// Iterate over our collection\nforeach ($documents as $document) {\necho $document-&gt;contents();\necho $document-&gt;metadata()-&gt;get('title');\n}\n</code></pre>"},{"location":"document/loader/CsvFileLoader/","title":"CsvFileLoader","text":"<p>The <code>CsvFileLoader</code> is a file loader that loads the contents of a single CSV file into multiple documents. Each row in the CSV file will be loaded as a separate document.</p> <p>It will use one of the columns in the CSV file as the document contents, and the rest of the columns as metadata.</p>"},{"location":"document/loader/CsvFileLoader/#requirements","title":"Requirements","text":"<p>The <code>CsvFileLoader</code> depends on the <code>league/csv</code> library to read the CSV file. This can be installed using composer.</p> <pre><code>composer require league/csv\n</code></pre>"},{"location":"document/loader/CsvFileLoader/#loading-documents","title":"Loading documents","text":"<p>The only argument required when creating a new <code>CsvFileLoader</code> is the path to the CSV file to load. By default the loader assumes that there's a column called \"contents\" containing the document contents. You can override this by passing a different column name as the <code>contentsColumn</code> parameter in the constructor.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\Loader\\CsvFileLoader;\n$loader = new CsvFileLoader(\npath: '/path/to/file.csv',\ncontentsColumn: 'contents'\n);\n$documents = $loader-&gt;load();\n</code></pre> <p>In addition to the metadata extracted from the CSV, the document will also get a path metadata entry containing the path to the CSV file, and an offset metadata entry containing the row number in the CSV file. If you have columns in the CSV file with the same name, they will take precedence.</p>"},{"location":"document/loader/CsvFileLoader/#overriding-csv-properties","title":"Overriding CSV properties","text":"<p>The loader will attempt to automatically detect the CSV delimiter, enclosure character, and escape character. If you want to override these, you can pass them as the <code>delimiter</code>, <code>enclosure</code>, and <code>escape</code> parameters in the constructor.</p> <pre><code>&lt;?php\n$loader = new CsvFileLoader(\npath: '/path/to/file.csv',\ncontentsColumn: 'contents',\ndelimiter: ',',\nenclosure: '\"',\nescape: '\\\\'\n);\n</code></pre>"},{"location":"document/loader/DirectoryLoader/","title":"DirectoryLoader","text":"<p>The <code>DirectoryLoader</code> allows you to load documents from a directory. It will recursively scan the directory for files and then load them using a provided secondary loader specific to the file format.</p>"},{"location":"document/loader/DirectoryLoader/#requirements","title":"Requirements","text":"<p>The <code>DirectoryLoader</code> depends on the <code>league/flysystem</code> library to access the filesystem. This can be installed using composer.</p> <pre><code>composer require league/flysystem\n</code></pre>"},{"location":"document/loader/DirectoryLoader/#loading-documents","title":"Loading documents","text":"<p>The minimum arguments needed when creating a new <code>DirectoryLoader</code> are an instance of <code>League\\Flysystem\\Filesystem</code> and the path to the directory to load documents from.</p> <pre><code>&lt;?php\nuse League\\Flysystem\\Filesystem;\nuse League\\Flysystem\\Local\\LocalFilesystemAdapter;\nuse Vexo\\Document\\Loader\\DirectoryLoader;\n// Create our filesystem instance\n$filesystem = new Filesystem(\nnew LocalFilesystemAdapter('/path/to/root/directory')\n);\n// Create the loader. Given the path below, it will end up looking at the\n// /path/to/root/directory/relative/path\n$loader = new DirectoryLoader(\nfilesystem: $filesystem,\npath: 'relative/path'\n);\n// Load our documents\n$documents = $loader-&gt;load();\n</code></pre>"},{"location":"document/loader/DirectoryLoader/#overriding-the-file-loader","title":"Overriding the file loader","text":"<p>By default the <code>DirectoryLoader</code> will use the <code>Vexo\\Document\\Loader\\TextFileLoader</code> to load files. If you want to use a different loader, you can pass a callable as the <code>fileLoader</code> parameter in the constructor. This callable is called for every file found in the directory. It is passed the <code>League\\Flysystem\\FilesystemReader</code> instance and the path to the file.</p> <p>This callable must return an instance of <code>Vexo\\Document\\Documents</code>, even if no files are loaded. In that case it should return an empty collection.</p> <pre><code>&lt;?php\nuse League\\Flysystem\\FilesystemReader;\n$loader = new DirectoryLoader(\nfilesystem: $filesystem,\npath: 'relative/path',\nfileLoader: function (FilesystemReader $filesystem, string $path): Documents {\nreturn (new MyCustomFileLoader($filesystem, $path))-&gt;load();\n}\n);\n</code></pre>"},{"location":"document/loader/DirectoryLoader/#loading-documents-recursively","title":"Loading documents recursively","text":"<p>By default the <code>DirectoryLoader</code> will only load files in the directory specified. If you want to load files recursively, you can set the <code>loadRecursive</code> parameter to <code>true</code> in the constructor.</p> <pre><code>&lt;?php\n$loader = new DirectoryLoader(\nfilesystem: $filesystem,\npath: 'relative/path',\nloadRecursive: true\n);\n</code></pre>"},{"location":"document/loader/DirectoryLoader/#filtering-files","title":"Filtering files","text":"<p>If you want to filter certain files from being loaded, you can pass a callable as the <code>filter</code> parameter in the constructor. This callable is called for every file found in the directory. It is passed an instance of <code>League\\Flysystem\\StorageAttributes</code> containing the file metadata. The callable should return <code>true</code> if the file should be loaded, or <code>false</code> if it should be skipped.</p> <p>In the example below we add a filter that will make sure the loader only loads files with the <code>.txt</code> extension.</p> <pre><code>&lt;?php\nuse League\\Flysystem\\StorageAttributes;\n$loader = new DirectoryLoader(\nfilesystem: $filesystem,\npath: 'relative/path',\nfilter: function (StorageAttributes $attributes): bool {\nreturn pathinfo($attributes-&gt;path(), PATHINFO_EXTENSION) == 'txt';\n}\n);\n</code></pre>"},{"location":"document/loader/DirectoryLoader/#loading-files-from-different-sources","title":"Loading files from different sources","text":"<p>Because we rely on the <code>league/flysystem</code> library, we can load files from a variety of sources. For example, we can load files from an S3 bucket.</p> <pre><code>&lt;?php\nuse Aws\\S3\\S3Client;\nuse League\\Flysystem\\AwsS3V3\\AwsS3V3Adapter;\nuse League\\Flysystem\\Filesystem;\nuse Vexo\\Document\\Loader\\DirectoryLoader;\n// Create our S3 client\n$s3 = new Aws\\S3\\S3Client(/* your options */)\n// Create our filesystem instance\n$filesystem = new Filesystem(\nnew AwsS3V3Adapter($s3, 'bucket-name')\n);\n// Create the loader\n$loader = new DirectoryLoader(\nfilesystem: $filesystem,\npath: 'relative/path'\n);\n</code></pre> <p>Flysystem supports AWS S3, Google Cloud, Azure Blob Storage, (S)FTP, and a few others. For more information on which other sources are available, check the league/flysystem documentation.</p>"},{"location":"document/loader/TextFileLoader/","title":"TextFileLoader","text":"<p>The <code>TextFileLoader</code> is a simple file loader that loads the contents of a single file as plain text.</p>"},{"location":"document/loader/TextFileLoader/#requirements","title":"Requirements","text":"<p>The <code>TextFileLoader</code> depends on the <code>league/flysystem</code> library to access the filesystem. This can be installed using composer.</p> <pre><code>composer require league/flysystem\n</code></pre>"},{"location":"document/loader/TextFileLoader/#example","title":"Example","text":"<pre><code>&lt;?php\nuse League\\Flysystem\\Filesystem;\nuse League\\Flysystem\\Local\\LocalFilesystemAdapter;\nuse Vexo\\Document\\Loader\\TextFileLoader;\n// Create our filesystem instance\n$filesystem = new Filesystem(\nnew LocalFilesystemAdapter('/path/to/root/directory')\n);\n// Create the loader\n$loader = new TextFileLoader(\nfilesystem: $filesystem,\npath: 'relative/path'\n);\n// Load the documents\n$documents = $loader-&gt;load();\n</code></pre> <p>Note that in the example above the <code>load</code> method will return a <code>Vexo\\Document\\Documents</code> instance containing a single document. This is because the <code>TextFileLoader</code> only loads a single file.</p> <p>If you want to load multiple files, have a look at the <code>DirectoryLoader</code>.</p>"},{"location":"document/loader/introduction/","title":"Introduction","text":"<p>The document loader allows you load new documents from a variety of sources for further processing. Generally there are two types of loaders, those that are based around a source, and those that are based around a format. These can be combined to load a wide variety of documents.</p> <p>All loaders implement the <code>Vexo\\Document\\Loader</code> interface, which has a single method, <code>load</code> which will return a <code>Vexo\\Document\\Documents</code> instance containing all the loaded documents.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\Documents;\ninterface Loader\n{\npublic function load(): Documents;\n}\n</code></pre>"},{"location":"document/retriever/VectorStoreRetriever/","title":"VectorStoreRetriever","text":"<p>The <code>VectorStoreRetriever</code> is a retriever that uses a <code>Vexo\\VectorStore\\VectorStore</code> to retrieve documents.</p>"},{"location":"document/retriever/VectorStoreRetriever/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Document\\Retriever\\VectorStoreRetriever;\n// Create the retriever\n$retriever = new VectorStoreRetriever(\nvectorStore: $vectorStore // Your `Vexo\\VectorStore\\VectorStore` instance\n);\n// Load the documents\n$documents = $retriever-&gt;retrieve(\nquery: 'How do I make a chocolate cake?',\nmaxResults: 10\n);\n</code></pre>"},{"location":"document/retriever/introduction/","title":"Introduction","text":"<p>Retrievers provide a simple way to retrieve documents based on a query. They are used by chains and agent tools to easily retrieve documents.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\Documents;\ninterface Retriever\n{\npublic function retrieve(string $query, int $maxResults = 4): Documents;\n}\n</code></pre>"},{"location":"document/text-splitter/CharacterTextSplitter/","title":"CharacterTextSplitter","text":"<p>The <code>CharacterTextSplitter</code> is a text splitter that recursively splits text into smaller chunks based on a maximum chunk size and a list of separator characters to split on.</p> <p>In the examples below we only show the <code>split</code> method, but the <code>splitDocuments</code> method works in the same way, except that it operates on and returns a <code>Documents</code> instance.</p>"},{"location":"document/text-splitter/CharacterTextSplitter/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\n// Create the text splitter\n$textSplitter = new CharacterTextSplitter(\nmaxChunkSize: 40,\nseparatorCharacters: [' ']\n);\n// Define our \"large\" piece of text\n$text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod '\n. 'tempor incididunt ut labore et dolore magna aliqua.';\n// Split the text\n$chunks = $textSplitter-&gt;split($text);\n// Chunks will now contain the following:\n// [\n//     'Lorem ipsum dolor sit amet, consectetur',\n//     'adipiscing elit, sed do eiusmod tempor',\n//     'incididunt ut labore et dolore magna',\n//     'aliqua.'\n// ]\n</code></pre>"},{"location":"document/text-splitter/CharacterTextSplitter/#recursive-splitting","title":"Recursive splitting","text":"<p>When you specify multiple split characters, the text splitter will split the text on the first character in the list. If the resulting chunks are still larger than the maximum chunk size, it will recursively split the chunks on the next character in the list, and so on.</p> <p>In the example below we first try to separate by paragraphs separated by two newlines, but if these are too large we will split on single newlines. If that's still too big, we will split on words separated by spaces, and if that's still too big we will split on characters.</p> <p>Note that if the split chunks are still too large after exhausting the list of separator characters, the text splitter will always split on characters.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\n// Create the text splitter\n$textSplitter = new CharacterTextSplitter(\nmaxChunkSize: 40,\nseparatorCharacters: [\"\\n\\n\", \"\\n\", ' ']\n);\n// Define our \"large\" piece of text\n$text = &lt;&lt;&lt;TEXT\n    This paragraph will fit in a chunk.\n    This is a paragraph which is too long\n    for a single chunk, but each line will\n    fit into a single chunk.\n    This paragraph and this line which it contains will not fit, so it will be split up.\n    This_is_an_extremely_long_word_that_will_be_split_to_fit_into_a_chunk.\nTEXT;\n// Split the text\n$chunks = $textSplitter-&gt;split($text);\n// Chunks will now contain the following:\n// [\n//     'This paragraph will fit in a chunk.',\n//     'This is a paragraph which is too long',\n//     'for a single chunk, but each line will',\n//     'fit into a single chunk.',\n//     'This paragraph and this line which it',\n//     'contains will not fit, so it will be',\n//     'split up.',\n//     'This_is_an_extremely_long_word_that_will',\n//     '_be_split_to_fit_into_a_chunk.'\n// ]\n</code></pre>"},{"location":"document/text-splitter/CharacterTextSplitter/#chunk-overlap","title":"Chunk overlap","text":"<p>Sometimes you may want to have some overlap between chunks. This can be useful when you want to make sure that for a given split chunk you have some context from the previous chunk. You can specify the overlap size by passing the <code>minChunkOverlap</code> parameter to the constructor.</p> <p>The splitter will try to respect your separator characters when choosing the overlap. The overlap will probably be larger than the <code>minChunkOverlap</code> parameter to make sure no undesirable splitting occurs.</p> <p>In the example below we split by space, and the overlaps chosen will never split a word in half if possible.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\n// Create the text splitter\n$textSplitter = new CharacterTextSplitter(\nmaxChunkSize: 40,\nminChunkOverlap: 10,\nseparatorCharacters: [' ']\n);\n// Define our \"large\" piece of text\n$text = 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor '\n. 'incididunt ut labore et dolore magna aliqua.';\n// Split the text\n$chunks = $textSplitter-&gt;split($text);\n// Chunks will now contain the following:\n// [\n//     'Lorem ipsum dolor sit amet, consectetur adipiscing',\n//     'adipiscing elit, sed do eiusmod tempor incididunt',\n//     'incididunt ut labore et dolore magna aliqua.'\n// ]\n</code></pre>"},{"location":"document/text-splitter/CharacterTextSplitter/#on-whitespace","title":"On whitespace","text":"<p>The text splitter will not trim whitespace by default from the resulting chunks, but it will ignore empty chunks. For instance if your text contains multiple consecutive spaces or newlines, and you split by those characters, the resulting chunks will not contain empty strings.</p> <p>However if you split by a newline character, and the resulting chunks contain whitespace, the whitespace will be preserved.</p> <p>You can force the text splitter to always trim chunks from whitespace by passing the <code>trimWhitespace</code> parameter to the constructor. When this is set, any chunks containing only whitespace will also be ignored, regardless of your separator characters.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\n// Create the text splitter\n$textSplitter = new CharacterTextSplitter(\nmaxChunkSize: 50,\nminChunkOverlap: 10,\nseparatorCharacters: ['_'],\ntrimWhitespace: true\n);\n// Define our \"large\" piece of text\n$text = 'Lorem_ipsum_dolor_sit_amet,_consectetur_ _ ___adipiscing_elit,_sed_do_eiusmod__'\n. ' _ __ _tempor_incididunt_ut_labore_et_dolore_magna_aliqua.';\n// Split the text\n$chunks = $textSplitter-&gt;split($text);\n// Chunks will now contain the following:\n// [\n//     'Lorem_ipsum_dolor_sit_amet,_consectetur_adipiscing',\n//     'adipiscing_elit,_sed_do_eiusmod_tempor_incididunt',\n//     'incididunt_ut_labore_et_dolore_magna_aliqua.'\n// ]\n</code></pre>"},{"location":"document/text-splitter/CharacterTextSplitter/#measuring-chunk-size","title":"Measuring chunk size","text":"<p>By default the text splitter relies on the <code>mb_strlen</code> function to determine text and chunk size. If you want to use a different method to measure the size of a chunk, you can pass a callable as the <code>sizeFunction</code> parameter to the constructor. This callable is passed the chunk text, and should return the size of the chunk as an integer.</p> <p>In the example below we use the <code>strlen</code> function to measure the size of a chunk. This will result in the text splitter counting bytes instead of characters.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\TextSplitter\\CharacterTextSplitter;\n// Create the text splitter\n$textSplitter = new CharacterTextSplitter(\nmaxChunkSize: 40,\nseparatorCharacters: [\"\\n\\n\", \"\\n\", ' '],\nsizeFunction: 'strlen'\n);\n</code></pre>"},{"location":"document/text-splitter/TokenTextSplitter/","title":"TokenTextSplitter","text":""},{"location":"document/text-splitter/introduction/","title":"Introduction","text":"<p>Text splitters allow you to split documents into smaller pieces of text. This is especially useful when you are tied to size limits of a vector store or language model in processing documents.</p> <p>All text splitters implement the <code>Vexo\\Document\\TextSplitter</code> interface, which has two methods, <code>split</code> and <code>splitDocuments</code>. The <code>split</code> method will split a string, into an array of smaller strings, while the <code>splitDocuments</code> method will split a collection of documents into smaller documents.</p> <p>The <code>splitDocuments</code> method uses the <code>split</code> method under the hood, passing it the contents of each document in the collection, and constructing a new document for each split piece of text. It will maintain metadata from the original document with the new documents.</p> <pre><code>&lt;?php\nuse Vexo\\Document\\Documents;\ninterface TextSplitter\n{\npublic function splitDocuments(Documents $document): Documents;\n/**\n     * @return array&lt;string&gt;\n     */\npublic function split(string $text): array;\n}\n</code></pre>"},{"location":"model/completion/OpenAI/","title":"OpenAI","text":"<p>The OpenAI model is a completion model that relies on OpenAI's completions API.</p>"},{"location":"model/completion/OpenAI/#requirements","title":"Requirements","text":"<p>The <code>OpenAIModel</code> requires the <code>openai-php/client</code> package to be installed.</p> <pre><code>composer require openai-php/client\n</code></pre> <p>You will also need an OpenAI API key. You can create an API key from the API keys page in your OpenAI account.</p>"},{"location":"model/completion/OpenAI/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Model\\Completion\\OpenAIModel;\n// Load our OpenAI client with our API key\n$openAI = \\OpenAI::client($_ENV['OPENAI_API_KEY']);\n// Create our OpenAI model based on the OpenAI completions API\n$model = new OpenAIModel($openAI-&gt;completions());\n// Generate a result\n$result = $model-&gt;generate('What is the capital of France?');\n</code></pre>"},{"location":"model/completion/OpenAI/#configuration","title":"Configuration","text":"<p>Most additional parameters that one would normally pass to the OpenAI completions API can be passed to the <code>OpenAIModel</code> constructor as additional parameters. The only exceptions are the <code>prompt</code>, <code>stop</code>, and <code>stream</code> parameters. The prompt and stop tokens are set when making the call to <code>generate</code> instead. The <code>stream</code> parameter is not supported at this time.</p> <p>See the OpenAI API reference for more information on these parameters.</p> <pre><code>&lt;?php\n// Create our OpenAI model based on the OpenAI completions API with extra parameters\n$model = new OpenAIModel(\ncompletions: $openAI-&gt;completions(),\nparameters: [\n'temperature' =&gt; 0.5,\n'max_tokens' =&gt; 100,\n'top_p' =&gt; 1,\n'n' =&gt; 1,\n'logprobs' =&gt; null,\n'echo' =&gt; false\n]\n);\n</code></pre>"},{"location":"model/completion/OpenAIChat/","title":"OpenAIChat","text":"<p>The OpenAI chat is a completion model that relies on OpenAI's chat API. This is the model needed to use OpenAI's GPT-4 model.</p>"},{"location":"model/completion/OpenAIChat/#requirements","title":"Requirements","text":"<p>The <code>OpenAIChatModel</code> requires the <code>openai-php/client</code> package to be installed.</p> <pre><code>composer require openai-php/client\n</code></pre> <p>You will also need an OpenAI API key. You can create an API key from the API keys page in your OpenAI account.</p>"},{"location":"model/completion/OpenAIChat/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Model\\Completion\\OpenAIChatModel;\n// Load our OpenAI client with our API key\n$openAI = \\OpenAI::client($_ENV['OPENAI_API_KEY']);\n// Create our OpenAI Chat model based on the OpenAI chat API\n$model = new OpenAIChatModel($openAI-&gt;chat());\n// Generate a result\n$result = $model-&gt;generate('What is the capital of France?');\n</code></pre>"},{"location":"model/completion/OpenAIChat/#configuration","title":"Configuration","text":"<p>Most additional parameters that one would normally pass to the OpenAI chat API can be passed to the <code>OpenAIChatModel</code> constructor as additional parameters. The only exceptions are the <code>stop</code> and <code>stream</code> parameters. The stop tokens are set when making the call to <code>generate</code> instead. The <code>stream</code> parameter is not supported at this time.</p> <p>You can specify <code>messages</code> parameters with an array of messages that you would like prefixed to the prompt. This is useful when you want to specify message history or systems messages that the model should take into account.</p> <p>See the OpenAI API reference for more information on these parameters.</p> <pre><code>&lt;?php\n// Create our OpenAI model based on the OpenAI completions API with extra parameters\n$model = new OpenAIModel(\ncompletions: $openAI-&gt;completions(),\nparameters: [\n'temperature' =&gt; 0.5,\n'max_tokens' =&gt; 100,\n'top_p' =&gt; 1,\n'n' =&gt; 1,\n'logprobs' =&gt; null,\n'messages' =&gt; [\n['role' =&gt; 'system', 'Provide the briefest possible answers.']\n]\n]\n);\n</code></pre>"},{"location":"model/completion/introduction/","title":"Introduction","text":"<p>Completion models allow you to generate text based on a prompt. We currently support OpenAI's completion and chat APIs.</p> <p>All completion models implement the <code>Vexo\\Model\\Completion\\Model</code> interface. It has a single method <code>generate</code> which accepts a text prompt and a an array of stop tokens.</p> <pre><code>&lt;?php\ninterface Model\n{\n/**\n     * @param array&lt;string&gt; $stops\n     */\npublic function generate(string $prompt, array $stops = []): Result;\n}\n</code></pre>"},{"location":"model/completion/introduction/#stop-tokens","title":"Stop tokens","text":"<p>Stop tokens are used to tell the model when to stop generating text. How many stop tokens you can provide depends on the specific model.</p>"},{"location":"model/completion/introduction/#interpreting-the-result","title":"Interpreting the result","text":"<p>The generate method returns an instance of <code>Vexo\\Model\\Completion\\Result</code> which contains the generated text(s) and some additional metadata provided by the model.</p> <p>Depending on how the model is configured, a result object may contain multiple generated texts. For example, the OpenAI model can generate multiple completions for a single prompt.</p> <p>The metadata provided by the model by include statistics like the amount of tokens used and the specific model used. This metadata is model-specific and cannot be relied upon to be present across different models</p> <pre><code>&lt;?php\n$result = $model-&gt;generate('What is the capital of France?');\n// Show the first generated text\necho $result-&gt;generation();\n// Get all generated texts\n$generations = $result-&gt;generations();\n// Get model metadata. May output something like this:\n//\n// Array\n// (\n//     [model] =&gt; text-davinci-003\n//     [usage] =&gt; Array\n//         (\n//             [prompt_tokens] =&gt; 5\n//             [completion_tokens] =&gt; 7\n//             [total_tokens] =&gt; 13\n//         )\n// )\nprint_r($result-&gt;metadata()-&gt;toArray());\n</code></pre>"},{"location":"model/completion/introduction/#monitoring-events","title":"Monitoring events","text":"<p>All completion models support event dispatching. You can pass a PSR-14 compatible event dispatcher in the <code>eventDispatcher</code> constructor argument which will then be used to dispatch events.</p> <p>The following is an example when injecting an event dispatcher into the <code>OpenAIModel</code>.</p> <pre><code>&lt;?php\nuse Vexo\\Contract\\Event\\Event;\nuse Vexo\\Model\\Completion\\OpenAIModel;\n// Load our OpenAI client with our API key\n$openAI = \\OpenAI::client($_ENV['OPENAI_API_KEY']);\n// Create our OpenAI model based on the OpenAI completions API\n$model = new OpenAIModel(\ncompletions: $openAI-&gt;completions(),\neventDispatcher: $eventDispatcher // Your PSR-14 compatible dispatcher\n);\n$eventDispatcher-&gt;subscribeTo(\nEvent::class,\nfunction (Event $event): void {\n// Handle the event\n}\n);\n</code></pre>"},{"location":"model/completion/introduction/#events","title":"Events","text":"<p>At this time the only event models will emit is the <code>ModelGeneratedResult</code> event when they generate a result. This event is emitted after the result has been generated and is ready to be returned. The event object has the following methods.</p> Method Description <code>prompt(): string</code> The prompt being used to generate the result. <code>stops(): array&lt;string&gt;</code> The stop tokens provided. <code>result(): Result</code> The actual result object containing the generated result."},{"location":"model/embedding/OpenAI/","title":"OpenAI","text":"<p>The OpenAI embedding model allows you to embed text into a vector space using OpenAI's embedding API.</p>"},{"location":"model/embedding/OpenAI/#requirements","title":"Requirements","text":"<p>The <code>OpenAIModel</code> requires the <code>openai-php/client</code> package to be installed.</p> <pre><code>composer require openai-php/client\n</code></pre> <p>You will also need an OpenAI API key. You can create an API key from the API keys page in your OpenAI account.</p>"},{"location":"model/embedding/OpenAI/#example","title":"Example","text":"<pre><code>&lt;?php\nuse Vexo\\Model\\Embedding\\OpenAIModel;\n// Load our OpenAI client with our API key\n$openAI = \\OpenAI::client($_ENV['OPENAI_API_KEY']);\n// Create our OpenAI model based on the OpenAI embedding API\n$model = new OpenAIModel($openAI-&gt;embeddings());\n// Embed a query\n$vector = $model-&gt;embedQuery('What is the capital of France?');\n// Embed a list of texts\n$vectors = $model-&gt;embedTexts([\n'The capital of France is Paris',\n'The capital of Germany is Berlin',\n'The capital of Italy is Rome'\n]);\n</code></pre>"},{"location":"model/embedding/introduction/","title":"Introduction","text":"<p>Embedding models allow you to embed text into a vector space. We currently support OpenAI's embedding API.</p> <p>All embedding models implement the <code>Vexo\\Model\\Embedding\\Model</code> interface. It has two methods, <code>embedQuery</code> and <code>embedTexts</code> to embed a query and a list of texts respectively. They return either an instance of <code>Vexo\\Contract\\Vector</code> or <code>Vexo\\Contract\\Vectors</code>.</p> <p>There are two separate methods for embedding queries and texts, as some implementations have different approaches to each.</p> <pre><code>&lt;?php\nuse Vexo\\Contract\\Vector;\nuse Vexo\\Contract\\Vectors;\ninterface Model\n{\npublic function embedQuery(string $query): Vector;\n/**\n     * @param array&lt;string&gt; $texts\n     */\npublic function embedTexts(array $texts): Vectors;\n}\n</code></pre>"}]}